import { createVNode as _createVNode } from "vue";
import { ref, watch, computed, onMounted, defineComponent } from "vue";
import { useEventListener } from "@vant/use";
import { makeNumericProp, makeStringProp, createNamespace } from "../utils/index.mjs";
const [name, bem] = createNamespace("text-ellipsis");
const textEllipsisProps = {
  rows: makeNumericProp(1),
  dots: makeStringProp("..."),
  content: makeStringProp(""),
  expandText: makeStringProp(""),
  collapseText: makeStringProp(""),
  position: makeStringProp("end")
};
var stdin_default = defineComponent({
  name,
  props: textEllipsisProps,
  emits: ["clickAction"],
  setup(props, {
    emit
  }) {
    const text = ref("");
    const expanded = ref(false);
    const hasAction = ref(false);
    const root = ref();
    const actionText = computed(() => expanded.value ? props.expandText : props.collapseText);
    const pxToNum = (value) => {
      if (!value)
        return 0;
      const match = value.match(/^\d*(\.\d*)?/);
      return match ? Number(match[0]) : 0;
    };
    const calcEllipsised = () => {
      const cloneContainer = () => {
        if (!root.value)
          return;
        const originStyle = window.getComputedStyle(root.value);
        const container2 = document.createElement("div");
        const styleNames = Array.prototype.slice.apply(originStyle);
        styleNames.forEach((name2) => {
          container2.style.setProperty(name2, originStyle.getPropertyValue(name2));
        });
        container2.style.position = "fixed";
        container2.style.zIndex = "-9999";
        container2.style.top = "-9999px";
        container2.style.height = "auto";
        container2.style.minHeight = "auto";
        container2.style.maxHeight = "auto";
        container2.innerText = props.content;
        document.body.appendChild(container2);
        return container2;
      };
      const calcEllipsisText = (container2, maxHeight2) => {
        const {
          content,
          position,
          dots
        } = props;
        const end = content.length;
        const calcEllipse = () => {
          const tail = (left, right) => {
            if (right - left <= 1) {
              if (position === "end") {
                return content.slice(0, left) + dots;
              }
              return dots + content.slice(right, end);
            }
            const middle2 = Math.round(left + right >> 1);
            if (position === "end") {
              container2.innerText = content.slice(0, middle2) + dots + actionText.value;
            } else {
              container2.innerText = dots + content.slice(middle2, end) + actionText.value;
            }
            if (container2.offsetHeight > maxHeight2) {
              if (position === "end") {
                return tail(left, middle2);
              }
              return tail(middle2, right);
            }
            if (position === "end") {
              return tail(middle2, right);
            }
            return tail(left, middle2);
          };
          container2.innerText = tail(0, end);
        };
        const middleTail = (leftPart, rightPart) => {
          if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
            return content.slice(0, leftPart[1]) + dots + dots + content.slice(rightPart[1], end);
          }
          const leftMiddle = Math.floor(leftPart[0] + leftPart[1] >> 1);
          const rightMiddle = Math.ceil(rightPart[0] + rightPart[1] >> 1);
          container2.innerText = props.content.slice(0, leftMiddle) + props.dots + actionText.value + props.dots + props.content.slice(rightMiddle, end);
          if (container2.offsetHeight >= maxHeight2) {
            return middleTail([leftPart[0], leftMiddle], [rightMiddle, rightPart[1]]);
          }
          return middleTail([leftMiddle, leftPart[1]], [rightPart[0], rightMiddle]);
        };
        const middle = 0 + end >> 1;
        props.position === "middle" ? container2.innerText = middleTail([0, middle], [middle, end]) : calcEllipse();
        return container2.innerText;
      };
      const container = cloneContainer();
      if (!container)
        return;
      const {
        paddingBottom,
        paddingTop,
        lineHeight
      } = container.style;
      const maxHeight = Math.ceil((Number(props.rows) + 0.5) * pxToNum(lineHeight) + pxToNum(paddingTop) + pxToNum(paddingBottom));
      if (maxHeight < container.offsetHeight) {
        hasAction.value = true;
        text.value = calcEllipsisText(container, maxHeight);
      } else {
        hasAction.value = false;
        text.value = props.content;
      }
      document.body.removeChild(container);
    };
    const onClickAction = (event) => {
      expanded.value = !expanded.value;
      emit("clickAction", event);
    };
    const renderAction = () => _createVNode("span", {
      "class": bem("action"),
      "onClick": onClickAction
    }, [expanded.value ? props.collapseText : props.expandText]);
    onMounted(calcEllipsised);
    watch(() => [props.content, props.rows, props.position], calcEllipsised);
    useEventListener("resize", calcEllipsised);
    return () => _createVNode("div", {
      "ref": root,
      "class": bem()
    }, [expanded.value ? props.content : text.value, hasAction.value ? renderAction() : null]);
  }
});
export {
  stdin_default as default,
  textEllipsisProps
};
